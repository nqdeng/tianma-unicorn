服务端依赖管理
------------------------------

文件可以通过元数据中的`requires`字段申明依赖，而独角兽会对这类文件启用*服务端依赖管理*。

例如有以下文件间依赖关系，下边的文件依赖上边的文件。

	  d   e
	   \ /
	    b   c
	     \ /
	      a

如果我们请求`a`时，独角兽会从`a`出发，*实时*解析整个依赖树，并按照*深度优先*和*后续遍历*的方式决定文件的输出顺序，并最终返回`a`自身及其依赖的所有文件的内容。因此有以下结果：

	=> GET /a
	<= HTTP/1.1 200 OK
	   ...
	   $(d) + $(e) + $(b) + $(c) + $(a)

如果没有在文件中申明依赖，我们就需要在浏览器端构造出`/??d.js,e.js,b.js,c.js,a.js`这样的请求来实现相同结果，但服务端依赖解析让我们只需要请求*入口文件*，而不用关系它的依赖。

### 多重入口

服务端依赖管理可以和文件合并结合起来使用。例如有以下依赖关系：

	    b   c  e   f
	     \ /    \ /
	      a      d

当通过`/??a,d`形式的URL请求多个文件时，有以下结果：

	=> GET /??a,d
	<= HTTP/1.1 200 OK
	   ...
	   $(b) + $(c) + $(a) + $(e) + $(f) + $(d)

### 动态依赖

有时候一个文件的依赖关系无法事先确定。例如在以下目录中，一个JS组件有可能依赖到任何一个多语言文件，但这种依赖关系需要由使用组件的页面来决定。

	- deploy/
		- i18n/
			en-us.js
			zh-cn.js
		dialog.js

*动态依赖*特性可用于解决这类问题。在`dialog.js`中，可以申明以下依赖关系;

	dialog.js	{ "requires": [ "i18n/{i18n}.js" ] }

可以看到，文件路径中有`{x}`这样的占位符，这是一个动态依赖申明。

如果我们使用通常的方式请求`dialog.js`，独角兽会*忽略*掉无法确定的动态依赖申明。

	=> GET /dialog.js
	<= HTTP/1.1 200 OK
	   ...
	   
	   $(dialog.js)

但是，我们可以在URL中带上对应的参数，帮助独角兽确定动态依赖申明。

	=> GET /dialog.js?i18n=zh-cn
	<= HTTP/1.1 200 OK
	   ...
	   
	   $(i18n/zh-cn.js) + $(dialog.js)

### 依赖排除

假设有以下依赖关系，其中的`x`是一个通用类库。

	    x   y
	     \ /
	      a

如果我们直接请求`a`，能得到以下响应：

	=> GET /a
	<= HTTP/1.1 200 OK
	   ...
	   
	   $(x) + $(y) + $(a)

但是如果我们希望单独请求`x`，让多个页面能共享`x`的缓存时，使用`a`的页面应该会发起以下两个请求：

	=> GET /x
	=> GET /a

如果`a`当中申明了对`x`的依赖，页面就会加载两份`x`的代码，不但影响性能，还可能出问题。如果我们不在`a`当中申明对`x`的依赖，这又是一种不太灵活的特殊处理。因此，我们可以按照以下方式发起第二次请求：

	=> GET /??-x,a

独角兽在处理这种请求时，会把`-`打头的文件及其依赖从整个依赖关系中排除掉，因此排除掉`x`的`a`的依赖关系如下：

	        y
	       /
	      a

所以独角兽会返回以下响应：

	<= HTTP/1.1 200 OK
	   ...
	   
	   $(y) + $(a)

另外，假设`x`和`y`两个文件都要做跨页面缓存时，以下请求方式是一种做法：

	=> GET /??x,y
	=> GET /??-x,-y,a

但这种方式不太灵活，每当需要跨页缓存的文件发生变动时，所有页面的URL都需要修改。于是我们可以采用以下方式：

	    x   y   x   y
	     \ /     \ /
	    common    a

我们可以创建一个`common`文件，专用于加载需要跨页缓存的文件，如此依赖，当需要从一次请求中排除被跨页缓存的文件时，就可以使用以下请求方式：

	=> GET /common
	=> GET /??-common,a

### 异常处理

#### 重复依赖

独角兽在对一次请求做服务端依赖管理时，会排除掉依赖树中的重复节点。因此，对于以下依赖关系：

	    b   c  c   e
	     \ /    \ /
	      a      d

有以下结果：

	=> GET /??a,d
	<= HTTP/1.1 200 OK
	   ...
	   $(b) + $(c) + $(a) + $(e) + $(d)

可以看到，`c`不会被合并两次。

#### 环状依赖

独角兽会自动打破环状依赖。对于以下依赖关系：

	    a
	    |
	    b   c
	     \ /
	      a

有以下结果：

	=> GET /a
	<= HTTP/1.1 200 OK
	   ...
	   $(b) + $(c) + $(a)

可以看到，`b`对`a`的环状依赖被打破掉。

#### 依赖缺失

无论是普通的依赖申明，还是动态依赖申明，一旦依赖的某个文件不存在时，独角兽会返回404响应。
